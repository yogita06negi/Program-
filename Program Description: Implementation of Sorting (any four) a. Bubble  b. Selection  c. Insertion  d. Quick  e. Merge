(a)Bubble
#include <stdio.h>

// Bubble Sort: keeps swapping adjacent elements
void bubbleSort(int a[], int n) {
    int i, j, temp;

   
    for(i = 0; i < n-1; i++) {

      
        for(j = 0; j < n-i-1; j++) {

           
            if(a[j] > a[j+1]) {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}

int main() {
    int a[] = {5, 2, 8, 1, 3};
    int n = 5;

    bubbleSort(a, n);

    printf("Bubble Sort Result: ");
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
}
(b) Selection
#include <stdio.h>

// Selection Sort: find smallest and put at correct position
void selectionSort(int a[], int n) {
    int i, j, min, temp;

    // Move boundary of unsorted array
    for(i = 0; i < n-1; i++) {
        min = i;  // assume current index has smallest value

        
        for(j = i+1; j < n; j++) {
            if(a[j] < a[min])
                min = j;
        }

        
        temp = a[i];
        a[i] = a[min];
        a[min] = temp;
    }
}

int main() {
    int a[] = {5, 2, 8, 1, 3};
    int n = 5;

    selectionSort(a, n);

    printf("Selection Sort Result: ");
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
}
#include <stdio.h>

// Selection Sort: find smallest and put at correct position
void selectionSort(int a[], int n) {
    int i, j, min, temp;

    // Move boundary of unsorted array
    for(i = 0; i < n-1; i++) {
        min = i;  // assume current index has smallest value

        // Find the smallest element in unsorted part
        for(j = i+1; j < n; j++) {
            if(a[j] < a[min])
                min = j;
        }

        // Swap smallest element with first element of unsorted part
        temp = a[i];
        a[i] = a[min];
        a[min] = temp;
    }
}

int main() {
    int a[] = {5, 2, 8, 1, 3};
    int n = 5;

    selectionSort(a, n);

    printf("Selection Sort Result: ");
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
}

(c )  Insertion sort 
#include <stdio.h>

// Insertion Sort: insert element in its correct position
void insertionSort(int a[], int n) {
    int i, key, j;

    // Start from 2nd element
    for(i = 1; i < n; i++) {

        key = a[i];       // take current element
        j = i - 1;

        // Shift bigger elements to the right
        while(j >= 0 && a[j] > key) {
            a[j+1] = a[j];
            j--;
        }

        // Place key at its correct position
        a[j+1] = key;
    }
}

int main() {
    int a[] = {5, 2, 8, 1, 3};
    int n = 5;

    insertionSort(a, n);

    printf("Insertion Sort Result: ");
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
}
(d ) Quick
#include <stdio.h>

// Partition: places pivot at correct position
int partition(int a[], int low, int high) {
    int pivot = a[high];   // select last element as pivot
    int i = low - 1;
    int temp;

    // Compare all elements with pivot
    for(int j = low; j < high; j++) {

        // If element < pivot → move it to left side
        if(a[j] < pivot) {
            i++;
            temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }

    // Place pivot in the correct index
    temp = a[i+1];
    a[i+1] = a[high];
    a[high] = temp;

    return i + 1;  // return pivot index
}

// QuickSort: recursively sort left & right parts
void quickSort(int a[], int low, int high) {
    if(low < high) {
        int pi = partition(a, low, high);

        quickSort(a, low, pi - 1);  // left side
        quickSort(a, pi + 1, high); // right side
    }
}

int main() {
    int a[] = {5, 2, 8, 1, 3};
    int n = 5;

    quickSort(a, 0, n - 1);

    printf("Quick Sort Result: ");
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
}
(e )  Merge
#include <stdio.h>

// Function to merge two sorted halves
void merge(int a[], int left, int mid, int right) {

    int n1 = mid - left + 1;   // size of left half
    int n2 = right - mid;      // size of right half

    int L[n1], R[n2];          // temporary arrays

    // Copy data to left temp array L[]
    for (int i = 0; i < n1; i++)
        L[i] = a[left + i];

    // Copy data to right temp array R[]
    for (int j = 0; j < n2; j++)
        R[j] = a[mid + 1 + j];

    int i = 0, j = 0, k = left;

    // Merge the two temp arrays back into original array
    while (i < n1 && j < n2) {

        // If left element is smaller → put it first
        if (L[i] <= R[j]) {
            a[k] = L[i];
            i++;
        }
        else {  // otherwise put right element first
            a[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy any remaining elements of L[]
    while (i < n1) {
        a[k] = L[i];
        i++;
        k++;
    }

    // Copy any remaining elements of R[]
    while (j < n2) {
        a[k] = R[j];
        j++;
        k++;
    }
}

// Merge Sort function (Divide & Conquer)
void mergeSort(int a[], int left, int right) {

    if (left < right) {

        int mid = (left + right) / 2;

        // Sort left half
        mergeSort(a, left, mid);

        // Sort right half
        mergeSort(a, mid + 1, right);

        // Merge both sorted halves
        merge(a, left, mid, right);
    }
}

int main() {

    int a[] = {5, 2, 8, 1, 3};
    int n = 5;

    mergeSort(a, 0, n - 1); // Call merge sort

    printf("Merge Sort Result: ");
    for (int i = 0; i < n; i++)
        printf("%d ", a[i]);

    return 0;
}
